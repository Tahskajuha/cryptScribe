import {
  require_argon2
} from "./chunk-UQHP4LYO.js";
import "./chunk-5QRROTB6.js";
import {
  __commonJS,
  __esm,
  __export,
  __reExport,
  __require,
  __toCommonJS
} from "./chunk-FU26JO2P.js";

// vite:dep-pre-bundle:external-conversion:/home/akshat/Projects/webJournal/node_modules/argon2-browser/dist/argon2.wasm
var argon2_exports = {};
__export(argon2_exports, {
  default: () => default2
});
import { default as default2 } from "/home/akshat/Projects/webJournal/node_modules/argon2-browser/dist/argon2.wasm";
import * as argon2_star from "/home/akshat/Projects/webJournal/node_modules/argon2-browser/dist/argon2.wasm";
var init_argon2 = __esm({
  "vite:dep-pre-bundle:external-conversion:/home/akshat/Projects/webJournal/node_modules/argon2-browser/dist/argon2.wasm"() {
    __reExport(argon2_exports, argon2_star);
  }
});

// node_modules/argon2-browser/lib/argon2.js
var require_argon22 = __commonJS({
  "node_modules/argon2-browser/lib/argon2.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.argon2 = factory();
      }
    })(typeof self !== "undefined" ? self : exports, function() {
      const global = typeof self !== "undefined" ? self : this;
      const ArgonType = {
        Argon2d: 0,
        Argon2i: 1,
        Argon2id: 2
      };
      function loadModule(mem) {
        if (loadModule._promise) {
          return loadModule._promise;
        }
        if (loadModule._module) {
          return Promise.resolve(loadModule._module);
        }
        let promise;
        if (global.process && global.process.versions && global.process.versions.node) {
          promise = loadWasmModule().then(
            (Module2) => new Promise((resolve) => {
              Module2.postRun = () => resolve(Module2);
            })
          );
        } else {
          promise = loadWasmBinary().then((wasmBinary) => {
            const wasmMemory = mem ? createWasmMemory(mem) : void 0;
            return initWasm(wasmBinary, wasmMemory);
          });
        }
        loadModule._promise = promise;
        return promise.then((Module2) => {
          loadModule._module = Module2;
          delete loadModule._promise;
          return Module2;
        });
      }
      function initWasm(wasmBinary, wasmMemory) {
        return new Promise((resolve) => {
          global.Module = {
            wasmBinary,
            wasmMemory,
            postRun() {
              resolve(Module);
            }
          };
          return loadWasmModule();
        });
      }
      function loadWasmModule() {
        if (global.loadArgon2WasmModule) {
          return global.loadArgon2WasmModule();
        }
        if (typeof __require === "function") {
          return Promise.resolve(require_argon2());
        }
        return import("./argon2-UF436WYA.js");
      }
      function loadWasmBinary() {
        if (global.loadArgon2WasmBinary) {
          return global.loadArgon2WasmBinary();
        }
        if (typeof __require === "function") {
          return Promise.resolve((init_argon2(), __toCommonJS(argon2_exports))).then(
            (wasmModule) => {
              return decodeWasmBinary(wasmModule);
            }
          );
        }
        const wasmPath = global.argon2WasmPath || "node_modules/argon2-browser/dist/argon2.wasm";
        return fetch(wasmPath).then((response) => response.arrayBuffer()).then((ab) => new Uint8Array(ab));
      }
      function decodeWasmBinary(base64) {
        const text = atob(base64);
        const binary = new Uint8Array(new ArrayBuffer(text.length));
        for (let i = 0; i < text.length; i++) {
          binary[i] = text.charCodeAt(i);
        }
        return binary;
      }
      function createWasmMemory(mem) {
        const KB = 1024;
        const MB = 1024 * KB;
        const GB = 1024 * MB;
        const WASM_PAGE_SIZE = 64 * KB;
        const totalMemory = (2 * GB - 64 * KB) / WASM_PAGE_SIZE;
        const initialMemory = Math.min(
          Math.max(Math.ceil(mem * KB / WASM_PAGE_SIZE), 256) + 256,
          totalMemory
        );
        return new WebAssembly.Memory({
          initial: initialMemory,
          maximum: totalMemory
        });
      }
      function allocateArray(Module2, arr) {
        return Module2.allocate(arr, "i8", Module2.ALLOC_NORMAL);
      }
      function allocateArrayStr(Module2, arr) {
        const nullTerminatedArray = new Uint8Array([...arr, 0]);
        return allocateArray(Module2, nullTerminatedArray);
      }
      function encodeUtf8(str) {
        if (typeof str !== "string") {
          return str;
        }
        if (typeof TextEncoder === "function") {
          return new TextEncoder().encode(str);
        } else if (typeof Buffer === "function") {
          return Buffer.from(str);
        } else {
          throw new Error("Don't know how to encode UTF8");
        }
      }
      function argon2Hash(params) {
        const mCost = params.mem || 1024;
        return loadModule(mCost).then((Module2) => {
          const tCost = params.time || 1;
          const parallelism = params.parallelism || 1;
          const pwdEncoded = encodeUtf8(params.pass);
          const pwd = allocateArrayStr(Module2, pwdEncoded);
          const pwdlen = pwdEncoded.length;
          const saltEncoded = encodeUtf8(params.salt);
          const salt = allocateArrayStr(Module2, saltEncoded);
          const saltlen = saltEncoded.length;
          const argon2Type = params.type || ArgonType.Argon2d;
          const hash = Module2.allocate(
            new Array(params.hashLen || 24),
            "i8",
            Module2.ALLOC_NORMAL
          );
          const secret = params.secret ? allocateArray(Module2, params.secret) : 0;
          const secretlen = params.secret ? params.secret.byteLength : 0;
          const ad = params.ad ? allocateArray(Module2, params.ad) : 0;
          const adlen = params.ad ? params.ad.byteLength : 0;
          const hashlen = params.hashLen || 24;
          const encodedlen = Module2._argon2_encodedlen(
            tCost,
            mCost,
            parallelism,
            saltlen,
            hashlen,
            argon2Type
          );
          const encoded = Module2.allocate(
            new Array(encodedlen + 1),
            "i8",
            Module2.ALLOC_NORMAL
          );
          const version = 19;
          let err;
          let res;
          try {
            res = Module2._argon2_hash_ext(
              tCost,
              mCost,
              parallelism,
              pwd,
              pwdlen,
              salt,
              saltlen,
              hash,
              hashlen,
              encoded,
              encodedlen,
              argon2Type,
              secret,
              secretlen,
              ad,
              adlen,
              version
            );
          } catch (e) {
            err = e;
          }
          let result;
          if (res === 0 && !err) {
            let hashStr = "";
            const hashArr = new Uint8Array(hashlen);
            for (let i = 0; i < hashlen; i++) {
              const byte = Module2.HEAP8[hash + i];
              hashArr[i] = byte;
              hashStr += ("0" + (255 & byte).toString(16)).slice(-2);
            }
            const encodedStr = Module2.UTF8ToString(encoded);
            result = {
              hash: hashArr,
              hashHex: hashStr,
              encoded: encodedStr
            };
          } else {
            try {
              if (!err) {
                err = Module2.UTF8ToString(
                  Module2._argon2_error_message(res)
                );
              }
            } catch (e) {
            }
            result = { message: err, code: res };
          }
          try {
            Module2._free(pwd);
            Module2._free(salt);
            Module2._free(hash);
            Module2._free(encoded);
            if (ad) {
              Module2._free(ad);
            }
            if (secret) {
              Module2._free(secret);
            }
          } catch (e) {
          }
          if (err) {
            throw result;
          } else {
            return result;
          }
        });
      }
      function argon2Verify(params) {
        return loadModule().then((Module2) => {
          const pwdEncoded = encodeUtf8(params.pass);
          const pwd = allocateArrayStr(Module2, pwdEncoded);
          const pwdlen = pwdEncoded.length;
          const secret = params.secret ? allocateArray(Module2, params.secret) : 0;
          const secretlen = params.secret ? params.secret.byteLength : 0;
          const ad = params.ad ? allocateArray(Module2, params.ad) : 0;
          const adlen = params.ad ? params.ad.byteLength : 0;
          const encEncoded = encodeUtf8(params.encoded);
          const enc = allocateArrayStr(Module2, encEncoded);
          let argon2Type = params.type;
          if (argon2Type === void 0) {
            let typeStr = params.encoded.split("$")[1];
            if (typeStr) {
              typeStr = typeStr.replace("a", "A");
              argon2Type = ArgonType[typeStr] || ArgonType.Argon2d;
            }
          }
          let err;
          let res;
          try {
            res = Module2._argon2_verify_ext(
              enc,
              pwd,
              pwdlen,
              secret,
              secretlen,
              ad,
              adlen,
              argon2Type
            );
          } catch (e) {
            err = e;
          }
          let result;
          if (res || err) {
            try {
              if (!err) {
                err = Module2.UTF8ToString(
                  Module2._argon2_error_message(res)
                );
              }
            } catch (e) {
            }
            result = { message: err, code: res };
          }
          try {
            Module2._free(pwd);
            Module2._free(enc);
          } catch (e) {
          }
          if (err) {
            throw result;
          } else {
            return result;
          }
        });
      }
      function unloadRuntime() {
        if (loadModule._module) {
          loadModule._module.unloadRuntime();
          delete loadModule._promise;
          delete loadModule._module;
        }
      }
      return {
        ArgonType,
        hash: argon2Hash,
        verify: argon2Verify,
        unloadRuntime
      };
    });
  }
});
export default require_argon22();
//# sourceMappingURL=argon2-browser.js.map
